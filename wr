#!/bin/bash
#
# Wrangler wrapper script for branch-isolated deployments
# See DEPLOYMENT_README.md for full documentation
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Dry run mode
DRY_RUN=false

# Wrangler command (use npx if wrangler not in PATH)
if command -v wrangler &> /dev/null; then
    WRANGLER="wrangler"
else
    WRANGLER="npx wrangler"
fi

# Run or simulate a command based on dry-run mode
run_cmd() {
    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}[DRY-RUN] Would execute:${NC} $*"
    else
        "$@"
    fi
}

# Get current git branch and slugify it
get_branch_slug() {
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$branch" ]; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi
    # Slugify: lowercase, replace / and _ with -, remove other special chars
    echo "$branch" | tr '[:upper:]' '[:lower:]' | sed 's/[/_]/-/g' | sed 's/[^a-z0-9-]//g'
}

# Get the wrangler config file for current branch
get_config_file() {
    local slug=$(get_branch_slug)
    if [ "$slug" = "main" ] || [ "$slug" = "master" ]; then
        echo "wrangler.main.toml"
    else
        echo "wrangler.${slug}.toml"
    fi
}

# Get the database name for current branch
get_db_name() {
    local slug=$(get_branch_slug)
    if [ "$slug" = "main" ] || [ "$slug" = "master" ]; then
        echo "avatarimaging-crm-db"
    else
        echo "avatarimaging-crm-db-${slug}"
    fi
}

# Create sandbox config from template
create_sandbox_config() {
    local config_file=$1
    local db_name=$2
    local slug=$(get_branch_slug)
    local worker_name="avatarimaging-cms-${slug}"

    echo -e "${BLUE}Creating sandbox environment for branch: ${slug}${NC}"

    # Create D1 database
    echo -e "${YELLOW}Creating D1 database: ${db_name}${NC}"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}[DRY-RUN] Would execute:${NC} wrangler d1 create $db_name"
        echo -e "${CYAN}[DRY-RUN] Would generate config file:${NC} $config_file"
        echo -e "${CYAN}[DRY-RUN] Worker name would be:${NC} $worker_name"
        return 0
    fi

    local db_output=$($WRANGLER d1 create "$db_name" 2>&1)

    # Extract database ID from output
    local db_id=$(echo "$db_output" | grep -oP 'database_id\s*=\s*"\K[^"]+' || echo "$db_output" | grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}')

    if [ -z "$db_id" ]; then
        echo -e "${RED}Error: Could not extract database ID from output${NC}"
        echo "$db_output"
        exit 1
    fi

    echo -e "${GREEN}Database created with ID: ${db_id}${NC}"

    # Generate config file from template
    cat > "$config_file" << EOF
# Sandbox configuration for branch: ${slug}
# Auto-generated by ./wr script
# See DEPLOYMENT_README.md for details

name = "${worker_name}"
main = "src/index.ts"
compatibility_date = "2025-01-02"
compatibility_flags = ["nodejs_compat"]

workers_dev = true

[assets]
directory = "./dist"
binding = "ASSETS"

[[d1_databases]]
binding = "DB"
database_name = "${db_name}"
database_id = "${db_id}"
migrations_dir = "migrations"

[[queues.producers]]
queue = "avatar-queue-${slug}"
binding = "QUEUE"

[[queues.consumers]]
queue = "avatar-queue-${slug}"
max_batch_size = 10
max_batch_timeout = 30
max_retries = 3

[ai]
binding = "AI"

[vars]
APP_NAME = "Avatar Imaging CRM (${slug})"
APP_VERSION = "1.0.0"
ENVIRONMENT = "sandbox"
FRONTEND_URL = "https://${worker_name}.workers.dev"
SMS_PROVIDER = "mobilemessage"
SMS_FROM_NUMBER = "+61400000000"
AI_MODEL_WARMNESS = "@cf/meta/llama-3.1-8b-instruct"
AI_MODEL_INTENT = "@cf/meta/llama-3.2-1b-instruct"
AI_MAX_TOKENS = 256
WARMNESS_RECALC_INTERVAL_HOURS = 24
SPEED_TO_LEAD_TARGET_MINUTES = 5

[observability]
enabled = true
head_sampling_rate = 1.0
EOF

    echo -e "${GREEN}Config file created: ${config_file}${NC}"
}

# Sync data from production
sync_from_prod() {
    local config_file=$1
    local db_name=$2
    local mode=$3

    local prod_db="avatarimaging-crm-db"
    local dump_file=".prod-dump-$(date +%s).sql"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}[DRY-RUN] Would execute:${NC} wrangler d1 export $prod_db --output=$dump_file -c wrangler.main.toml"
        if [ "$mode" = "incremental" ]; then
            echo -e "${CYAN}[DRY-RUN] Would convert:${NC} INSERT INTO -> INSERT OR IGNORE INTO"
        fi
        echo -e "${CYAN}[DRY-RUN] Would execute:${NC} wrangler d1 execute $db_name --file=$dump_file -c $config_file"
        echo -e "${CYAN}[DRY-RUN] Would cleanup:${NC} rm $dump_file"
        return 0
    fi

    echo -e "${BLUE}Exporting data from production database...${NC}"
    $WRANGLER d1 export "$prod_db" --output="$dump_file" -c wrangler.main.toml

    if [ "$mode" = "incremental" ]; then
        echo -e "${YELLOW}Converting to incremental mode (INSERT OR IGNORE)...${NC}"
        sed -i 's/INSERT INTO/INSERT OR IGNORE INTO/g' "$dump_file"
    fi

    echo -e "${BLUE}Importing data to sandbox database...${NC}"
    $WRANGLER d1 execute "$db_name" --file="$dump_file" -c "$config_file"

    # Cleanup
    rm -f "$dump_file"

    echo -e "${GREEN}Data sync complete!${NC}"
}

# Prompt for sync mode
prompt_sync_mode() {
    echo ""
    echo -e "${YELLOW}Sync data from production?${NC}"
    echo "  1) Full replace (INSERT) - overwrites existing data"
    echo "  2) Incremental (INSERT OR IGNORE) - keeps existing data"
    echo "  3) Skip - don't sync data"
    echo ""
    read -p "Choose [1/2/3]: " choice

    case $choice in
        1) echo "full" ;;
        2) echo "incremental" ;;
        *) echo "skip" ;;
    esac
}

# Main script
main() {
    # Parse --dry-run flag
    local args=()
    for arg in "$@"; do
        if [ "$arg" = "--dry-run" ]; then
            DRY_RUN=true
        else
            args+=("$arg")
        fi
    done
    set -- "${args[@]}"

    local config_file=$(get_config_file)
    local db_name=$(get_db_name)
    local slug=$(get_branch_slug)

    echo -e "${BLUE}Branch: ${slug}${NC}"
    echo -e "${BLUE}Config: ${config_file}${NC}"
    echo -e "${BLUE}Database: ${db_name}${NC}"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}[DRY-RUN MODE]${NC}"
    fi

    # Show help if no command
    if [ -z "$1" ]; then
        echo ""
        echo "Usage: ./wr <command> [options] [--dry-run]"
        echo ""
        echo "Commands:"
        echo "  deploy              Deploy to branch environment"
        echo "  d1 migrations apply Apply migrations and sync data"
        echo "  sync-from-prod      Sync data from production"
        echo "  <any>               Pass through to wrangler"
        echo ""
        echo "Options:"
        echo "  --dry-run           Show what would be done without executing"
        exit 0
    fi

    # Check if config exists, create if not (except for main)
    if [ ! -f "$config_file" ]; then
        if [ "$slug" = "main" ] || [ "$slug" = "master" ]; then
            echo -e "${RED}Error: wrangler.main.toml not found. This file should exist for production.${NC}"
            exit 1
        fi
        echo -e "${YELLOW}Config not found, will create sandbox...${NC}"
        create_sandbox_config "$config_file" "$db_name"
    else
        echo -e "${GREEN}Config exists: ${config_file}${NC}"
    fi

    # Handle special commands
    case "$1" in
        sync-from-prod)
            if [ "$slug" = "main" ] || [ "$slug" = "master" ]; then
                echo -e "${RED}Error: Cannot sync from prod to prod${NC}"
                exit 1
            fi

            local mode=${2:-$(prompt_sync_mode)}
            if [ "$mode" != "skip" ]; then
                sync_from_prod "$config_file" "$db_name" "$mode"
            fi
            ;;

        d1)
            # Pass through to wrangler with config
            shift
            run_cmd $WRANGLER d1 "$@" -c "$config_file"

            # If migrations were applied, prompt for data sync
            if [ "$1" = "migrations" ] && [ "$2" = "apply" ]; then
                if [ "$slug" != "main" ] && [ "$slug" != "master" ]; then
                    local mode=$(prompt_sync_mode)
                    if [ "$mode" != "skip" ]; then
                        sync_from_prod "$config_file" "$db_name" "$mode"
                    fi
                fi
            fi
            ;;

        deploy)
            shift
            echo -e "${GREEN}Deploying to: ${slug}${NC}"
            run_cmd $WRANGLER deploy "$@" -c "$config_file"
            ;;

        *)
            # Pass through any other command
            run_cmd $WRANGLER "$@" -c "$config_file"
            ;;
    esac
}

# Run main with all arguments
main "$@"
